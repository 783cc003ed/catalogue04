# Buzzing on Christmas Eve: Trigona Ransomware in 3 Hours

Авторы: 


Ссылка на контент: 
https://thedfirreport.com/2024/01/29/buzzing-on-christmas-eve-trigona-ransomware-in-3-hours/

Краткое содержание: 

<blockquote>
Upon gaining access, the threat actor deployed a toolkit onto the beachhead host, which included an assortment of batch scripts, executables, and the SoftPerfect Netscan tool.   ...   <br>The threat actor then staged a ransomware binary on each of the hosts they had access to.   ...   <br>In this case, the ransomware strain deployed was Trigona, which was executed approximately two hours and 49 minutes after the initial access.   ...   <br>Our Private Ruleset is exclusively curated using insights derived from Private Threat Briefs and internal cases, focusing on Sigma rules.   ...   <br>This is corroborated with event ID 4778 reporting a resumed session for the user and IP address.   ...   <br>We observed execution of several scripts detailed in the exfiltration section, and highlight others throughout the rest of the report that the threat actor dropped in the network but were not utilized.   ...   <br>Two files were created by threat actors in order to create a new local user and add it to the local administrators group and Remote Desktop Users group.   ...   <br>The script also creates a user named Support with a password of Kawa72ws.   ...   <br>Interestingly enough, the threat actor in this case did not execute this script, preferring to manually run some of the commands (or similar commands) on the system to disable defenses.   ...   <br>Of note, two of the third-party tools referenced by the script (SU64 and PSKILL64) were not included in the tool drop.   ...   <br>After these first commands, the threat actor employed Netscan to perform network discovery.   ...   <br>The default Netscan only includes a couple of sample “Applications” – it appears the threat actor in this case has highly customized the instance of Netscan to use it as a centralized command tool to automate many actions, including removing Antivirus, adding new users, and modifying the firewall, all using PSEXEC.   ...   <br>Several other IP discovery scripts were also dropped by the threat actor but were not observed used during this intrusion.   ...   <br>Remote Desktop Protocol (RDP) was all that was necessary to facilitate the exfiltration of data and successful execution of ransomware.   ...   <br>Like with many other batch scripts already reviewed, openrdp.bat was another script that was part of the threat actor toolkit that did not see execution during this intrusion as RDP access was readily available across the environment.   ...   <br>Another tool (presumably to be used for lateral movement) dropped by the threat actor, but not employed in this incident, is a tool named Remote Desktop Plus.   ...   <br>]6 and from the remote host named WIN-L1MS2GT1R2G.   ...   <br>From this session, the ransomware files were staged and executed.   ...   <br>Two different suspicious batch scripts were dropped using RDP in the built-in Administrator’s Music folder on the beachhead and one of the file servers.   ...   <br>Like past reports this threat actor also used the Mega.io service as the remote exfiltration location for the stolen files.   ...   <br>The configuration file for Rclone used by the threat actor was encrypted.   ...   <br>63d77e05-c651-4163-9851-d7e20a9313c3 : New Firewall Rule Allowing Incoming RDP Connections 00913ec7-2749-4584-bf1b-47a265198bca : MSPaint Opening File from Remote Host 53ad7638-3862-49a2-9ddd-af7132f9e598 : Using Netscan for Post-Scanning Lateral Movement 1c289d45-fa72-4465-80ed-32a9ae67804b : Hide Windows Defender Settings b0df6ced-5f5a-4ff6-b375-a464599e78c1 : Execution of Batch Scripts from Suspicious User Directories   ...   
</blockquote>

Тэги: 


Дата публикования: 
2024-01-29T00:52:11+00:00

---

# Sensecon 23: from Windows drivers to an almost fully working EDR

Авторы: 


Ссылка на контент: 
https://sensepost.com/blog/2024/sensecon-23-from-windows-drivers-to-an-almost-fully-working-edr/

Краткое содержание: 

<blockquote>
First we will take a look at the history of anti-viruses, see how they worked and why they relied on a kernel driver, then we will see how to create a custom kernel driver and finally how to turn it into a almost fully working EDR.   ...   <br>Its usage is fully documented and the function is pretty easy to use, all you need to do is to specify the path to the file you want to open as well as the desired access on it (read, write or append).   ...   <br>This instruction is the one that will tell the CPU to switch from the user space to the kernel space and then jump on the kernel address where the NtCreateFile function is located in the kernel.   ...   <br>In order to find the address of the function, it will need both the system call number, stored in the EAX register, and the SSDT.   ...   <br>Looking back at the SSDT, it appears that if you modify the address of the kernel functions, you can basically redirect the code flow pretty much anywhere you want.   ...   <br>This mechanism is the first one we are going to implement in our EDR, but before we get to that we will need a kernel driver and thus we’ll need to have a better understanding of what a driver is and how we can develop one.   ...   <br>Before you start developing a driver, you will have to determine what your needs are and what your driver will be used for.   ...   <br>In our case, sadly, we’ll need to develop a kernel driver (KMDF) since we will use kernel functions and to develop a driver we will need a development environment!   ...   <br>To do so we’ll have to add the following key:   ...   <br>// Creating the symlink that we will use to contact our driver status = IoCreateSymbolicLink( &symlinkName, // The symbolic link name &deviceName   // The device name );   ...   <br>Now that the driver is running, let’s take a look at the content of a basic Windows kernel driver!   ...   <br>If we take a look at content of the DriverEntry’s function, we can see that, apart from the DbgPrintEx functions used to print messages in dbgview, two functions are called:   ...   <br>In our code, the routine is the following function:   ...   <br>And that’s it, at this point we have got a working kernel driver.   ...   <br>As we have seen before, function callbacks are functions that can be used by a driver to register what is called a kernel callback.   ...   <br>In the following code, this routine is the CreateProcessNotifyRoutine function:   ...   <br>Being aware of process creation sure is interesting but we need to develop logic that is going to allow our EDR to determine whether or not the target process should be created in the first place.   ...   <br>The prototype for this function is the following:   ...   <br>As an attacker these arrays are specifically interesting because if you can overwrite them or remove the pointers, you will basically be able to “blind” the EDR and thus prevent it from monitoring the system (and there is already a pretty cool tool that will allow you doing that, CheekyBlinder).   ...   <br>At this point the only thing I wanted MyDumbEDR to be able to detect is binaries that attempt to inject shellcode into remote process using the following simple CreateRemoteThread technique:   ...   <br>if (isOpenProcessPresent && isVirtualAllocExPresent && isWriteProcessMemoryPresent && isCreateRemoteThreadPresent) { return TRUE; } else { return FALSE; } return FALSE; }   ...   <br>printf("\n\n"); } return 0; }   ...   <br>To modify the flow of a function from NTDLL.dll, we simply need to parse the DLL, find the functions we want to hook and modify its code so that it jumps to the code of our EDR instead.   ...   <br>Because the NtAllocateVirtualMemory is the function from NTDLL.dll that is used to allocate and protect a memory space.   ...   <br>That’s the job of the RemoteInjector agent which receives, from the driver, the PID of the process in which to inject the DLL:   ...   <br>// Opening the process with necessary privileges HANDLE hProcess = OpenProcess(PROCESS_CREATE_THREAD | PROCESS_QUERY_INFORMATION | PROCESS_VM_OPERATION | PROCESS_VM_WRITE | PROCESS_VM_READ, FALSE, target_pid); if (hProcess == NULL) { printf("Can't open handle, error: % lu\n", GetLastError()); return FALSE; } printf("\tOpen handle on PID: %d\n", target_pid);   ...   <br>Running all of that, we can see that the assembly code of the NtAllocateVirtualMemory function of the NTDLL.dll of a process that was injected is the following:   ...   <br>As you can see the first assembly instruction of the hooked NtAllocateVirtualMemory function is a jmp which will redirect the code flow from the NTDLL.dll to the address “00007FFAA06A0FD6” which is… Our injected EDR’s DLL:   ...   <br>Now that we have our two agents as well as the driver, we can compile them and launch the entire project to see it in action!   ...   <br>Throughout this article we have seen how to develop a Windows driver, how to turn it into a EDR’s kernel driver and how to build a dummy EDR.   ...   
</blockquote>

Тэги: 
['callbacks', 'driver', 'edr', 'hooking', 'kernel', 'rootkit', 'rootkits', 'shellcode', 'shellcodes', 'ssdt', 'winapi', 'windows']

Дата публикования: 
2024-01-31T00:00:00

---

