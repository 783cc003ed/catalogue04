# Malicious ISO File Leads to Domain Wide Ransomware

Авторы: 


Ссылка на контент: 
https://thedfirreport.com/2023/04/03/malicious-iso-file-leads-to-domain-wide-ransomware/

Краткое содержание: 

<blockquote>
Around 16 hours after the initial execution, the first Cobalt Strike beacon DLL was executed from the IcedID malware.   ...   <br>After this, the threat actors began their first lateral movement to a server in the environment by copying their Cobalt Strike DLL over to the host and executing it via a remote service.   ...   <br>Some two hours later, another Cobalt Strike beacon was executed.   ...   <br>Around an hour after starting the RDP session, the threat actors executed a PowerShell command to disable Windows Defender Antivirus on the host and reviewed Group Policy Objects for the domain.   ...   <br>The Cobalt Strike beacons then began to execute successfully on the domain controller.   ...   <br>Now, with Cobalt Strike beacons on the domain controller, the threat actors continued with discovery actions using Invoke-ShareFinder and other PowerShell and system utilities.   ...   <br>During this time, Windows event logs point to the threat actors completing DCSync activities on one of the domain controllers.   ...   <br>Near the end of the day, the threat actors moved to install AnyDesk on several servers including a backup management host, likely as a further means of persistence or later command and control.   ...   <br>Finally, they connected to a domain controller and dropped three scripts; one to copy the ransomware executable to all hosts, one to reset every users password in the organization, and a final one to execute the staged ransomware payload using PsExec.   ...   <br>This ISO file contains a LNK named documents and a hidden directory named max containing a cobalt strike DLL beacon and a batch file.   ...   <br>As a consequence, when the victim clicked on the LNK file, it triggered the execution of the batch file eyewear.bat   ...   <br>The batch file eyewear.bat then executed two commands:   ...   <br>On the second day of the intrusion, the threat actors used the IcedID malware to drop a Cobalt Strike beacon and execut it using regsvr32.exe.   ...   <br>This is a common technique used by threat actors, and implemented by the GetSystemCobalt Strike command.   ...   <br>On the second day of the intrusion, a spike in NetLogon traffic was observed from the beachhead host to a domain controller.   ...   <br>The threat actors delivered the initial malware as a zip file, with the contents of a ISO file, which contained their payload to gain access to the target environment.   ...   <br>This is a known behavior of Cobalt Strike and its function shinject, which can be used to inject a new beacon or a specific program to another process on the victim’s computer.   ...   <br>Commands used to collect credentials and export to text files stored in the C:\ProgramData folder included the following:   ...   <br>This process was invoked by RunDLL32.exe which was an injected Cobalt Strike beacon reaching out to the command and control server at 111.90.143[.   ...   <br>From Nigu.exe (Cobalt Strike beacon), the following LOLBAS commands were observed:   ...   <br>Discovery commands observed from other Cobalt Strike beacons using LOLBAS included:   ...   <br>➝ C:\Windows\system32\cmd.exe /C powershell.exe get-ADcomputer -Filter * | Where-Object {$a=$_.name; $_.DistinguishedName -ne "CN=$a,OU=[REDACTED],DC=[REDACTED],DC=[REDACTED]"} | Sort-Object name | Select-Object name | Export-csv C:\ProgramData\ADComputers.csv -NoTypeInformation   ...   <br>Other operator errors observed included the use of Cobalt Strike commands being passed as a parameter instead of a beacon task.   ...   <br>In this case, there is a clear indication that the operator launched the Invoke-ShareFinder command via Cobalt Strike, as observed in Event ID 800:   ...   <br>Other discovery activities observed included a domain host discovery script via PowerShell.   ...   <br>While Adget was seen used, prior to that tool being run the threat actors also deployed the tried and true AdFind, which was renamed to find.exe and called using find.bat.   ...   <br>The dS.bat file was executed by the injected Rundll32.exe process.   ...   <br>Threat actors used wmic.exe in order to execute PowerShell Cobalt Strike beacons on multiple workstations and servers.   ...   <br>The beacon C:\ProgramData\lsass.exe was used to proxy RDP connections and connect to another computer.   ...   <br>Proxying RDP traffic via a process such as a Cobalt Strike beacon reduces the exposure of the threat actor’s own infrastructure, and blends RDP activity to those of internal hosts on the network.   ...   <br>To achieve collection of various directories on multiple hosts, the threat actors used the dir command through the administrative share c$ and redirected the output to a file text named listing.txt.   ...   <br>In this case, ShareFinder.txt was created in the ProgramData folder by the ShareFinder.ps1 script.   ...   <br>This host name was also in the Security events:   ...   <br>]162 and 165.231.182[.]14.   ...   <br>On the backup server, rclone.exe was used in order to exfiltrate data to a MEGA cloud storage.   ...   <br>The threat actors dropped the first of their ransomware binaries on the fourth day of the intrusion.   ...   <br>The locker_64.exe file was then renamed to 64.exe and executed using the text file in the command arguments:   ...   <br>The threat actors attempted to execute the malware across all hosts in the target list, but only execution on the backup server was observed.   ...   <br>They then executed a new Cobalt Strike PowerShell beacon on a 3rd server and executed the ramsomware using that.   ...   <br>The script pass.bat proceeded to reset all the user accounts in the domain to a single password set by the threat actors.   ...   
</blockquote>

Тэги: 


Дата публикования: 
2023-04-03T01:27:10+00:00

---

# Java Exploitation Restrictions in Modern JDK Times

Авторы: 


Ссылка на контент: 
https://code-white.com/blog/2023-04-java-exploitation-restrictions-in-modern-jdk-times/

Краткое содержание: 

<blockquote>
But our journey did not begin with deserialization in the first place but rather looking for alternative ways of executing Java code in recent JDK versions.   ...   <br>Often code execution payloads in Java end with a final call to java.lang.Runtime.getRuntime().exec(args), at least in a proof-of-concept exploitation phase.   ...   <br>But this can also be applied to Java exploitation.   ...   <br>It is a well-known fact that an attacker has the choice between different approaches to stay within the JVM to execute arbitrary Java code, with new javax.script.ScriptEngineManager().getEngineByName(engineName).eval(scriptCode) probably being the most popular one over the last years.   ...   <br>But since Nashorn was marked as deprecated in Java 11 (JEP 335), and removed entirely in Java 15 (JEP 372), this means that a target using a JDK version >= 15 won’t process JavaScript payloads anymore by default.   ...   <br>Instead of hoping for other manually added JavaScript engines by developers for a specific target, we could make use of a “new” Java code evaluation API: JShell, a read-eval-print loop (REPL) tool that was introduced with Java 9 (JEP 222).   ...   <br>“The input should be exactly one complete snippet of source code, that is, one expression, statement, variable declaration, method declaration, class declaration, or import.”   ...   <br>So, we started to play with some Java code snippets using the JShell API.   ...   <br>We don’t have to “fix” the import issue mentioned above but can still use all built-in JDK classes by referencing them accordingly: java.nio.file.Files.createFile(java.nio.file.Paths.get(\"/tmp/RCE\"));.   ...   <br>But creating a payload with a recent version of JDK (version 17 in our case) revealed the following error.   ...   <br>This is called illegal reflective access and by default is not permitted in JDK 16 and later.   ...   <br>Since CommonsCollections6 (and most of other gadgets) make heavy use of the Java Reflection API via java.lang.reflect.Field.setAccessible(boolean flag), this restriction has to be taken into account accordingly.   ...   <br>If you add the --add-opens parameters to the ysoserial.Deserializer as well, deserialization works as expected of course but in a remote attack scenario we obviously don’t have control over this!   ...   <br>Conclusions Use JShell instead of ScriptEngineManager for JDK versions >= 15 (side note: this is not available in JREs!).   ...   <br>For JDK versions >= 16, rely on known (or find new) Java deserialization gadgets which do not depend on access to internal JDK class members etc.   ...   
</blockquote>

Тэги: 


Дата публикования: 
2023-04-11T00:00:00

---

